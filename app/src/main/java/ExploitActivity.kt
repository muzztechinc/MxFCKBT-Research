package au.com.proximitybreach.lab

import android.bluetooth.BluetoothDevice
import android.bluetooth.BluetoothSocket
import android.os.Bundle
import android.util.Log
import android.widget.Button
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
import au.com.proximitybreach.lab.databinding.ActivityExploitBinding
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.IOException
import java.util.UUID

class ExploitActivity : AppCompatActivity() {

    private lateinit var binding: ActivityExploitBinding
    private lateinit var targetDevice: BluetoothDevice
    private lateinit var statusText: TextView
    private lateinit var exploitButton: Button
    private var socket: BluetoothSocket? = null

    private val SPP_UUID = UUID.fromString("00001101-0000-1000-8000-00805F9B34FB")

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityExploitBinding.inflate(layoutInflater)
        setContentView(binding.root)

        statusText = binding.statusText
        exploitButton = binding.exploitButton

        val deviceAddress = intent.getStringExtra("DEVICE_ADDRESS")
        val deviceName = intent.getStringExtra("DEVICE_NAME")

        targetDevice = bluetoothAdapter.getRemoteDevice(deviceAddress)
        binding.targetDeviceText.text = "Target: ${deviceName ?: "Unknown"} ($deviceAddress)"

        setupExploitButtons()
    }

    private fun setupExploitButtons() {
        binding.exploitButton.setOnClickListener {
            CoroutineScope(Dispatchers.IO).launch {
                attemptRfcommConnection()
            }
        }

        binding.bruteforceButton.setOnClickListener {
            CoroutineScope(Dispatchers.IO).launch {
                attemptPinBruteforce()
            }
        }

        binding.sdpButton.setOnClickListener {
            CoroutineScope(Dispatchers.IO).launch {
                attemptSdpExploit()
            }
        }
    }

    private suspend fun attemptRfcommConnection() {
        withContext(Dispatchers.Main) {
            statusText.text = "Attempting RFCOMM connection..."
        }

        try {
            socket = targetDevice.createRfcommSocketToServiceRecord(SPP_UUID)
            socket?.connect()
            
            withContext(Dispatchers.Main) {
                statusText.text = "RFCOMM connection successful!"
                binding.connectionStatus.text = "CONNECTED"
            }
            
            // Test message
            val outputStream = socket?.outputStream
            outputStream?.write("TEST_PAYLOAD_FROM_RESEARCH_APP\n".toByteArray())
            
        } catch (e: IOException) {
            withContext(Dispatchers.Main) {
                statusText.text = "RFCOMM failed: ${e.message}"
            }
            Log.e("ExploitActivity", "RFCOMM connection failed", e)
        }
    }

    private suspend fun attemptPinBruteforce() {
        withContext(Dispatchers.Main) {
            statusText.text = "Starting PIN bruteforce simulation..."
        }

        val commonPins = listOf("0000", "1234", "1111", "9999", "1212")
        
        for (pin in commonPins) {
            withContext(Dispatchers.Main) {
                statusText.text = "Trying PIN: $pin"
            }
            
            // Simulate PIN attempt (actual implementation would use reflection/hidden APIs)
            Log.d("ExploitActivity", "Simulating PIN attempt: $pin")
            
            kotlinx.coroutines.delay(1000) // Delay between attempts
        }
        
        withContext(Dispatchers.Main) {
            statusText.text = "PIN bruteforce simulation completed"
        }
    }

    private suspend fun attemptSdpExploit() {
        withContext(Dispatchers.Main) {
            statusText.text = "Attempting SDP exploit simulation..."
        }

        // Simulate malicious SDP record sending
        try {
            // This would actually require low-level Bluetooth access
            Log.d("ExploitActivity", "Simulating SDP exploit against ${targetDevice.address}")
            
            withContext(Dispatchers.Main) {
                statusText.text = "SDP exploit simulation completed"
            }
            
        } catch (e: Exception) {
            withContext(Dispatchers.Main) {
                statusText.text = "SDP exploit failed: ${e.message}"
            }
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        try {
            socket?.close()
        } catch (e: IOException) {
            Log.e("ExploitActivity", "Error closing socket", e)
        }
    }
}
